{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"Vue 全家桶 ！！","date":"2019-02-09T13:28:53.295Z","updated":"2019-01-21T14:05:23.039Z","comments":true,"path":"2019/02/09/Vue 全家桶 ！！/","link":"","permalink":"http://yoursite.com/2019/02/09/Vue 全家桶 ！！/","excerpt":"","text":"[TOC] Vue 全家桶 ！！授课老师： 渡一教育 杉杉老师 笔记： LDW 班级： 渡一五期进阶班 玩转 vue 全家桶 一一、创建一个Vue实例CDN地址：1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 创建实例对象123456789&lt;div id=\"app\"&gt;&#123;&#123;info&#125;&#125;&lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el:'#app', //被vue接管的dom元素才能使用vue的语法 data:&#123; info:\"Vue\", &#125;, &#125;) &lt;/script&gt; 双花括号语法： 双花括号里面的属性会上vue实例中的data上找对应的属性名， 双花括号里面也可以进行三目运算 1&lt;div id=\"app\"&gt;&#123;&#123;false? name:'hahaha'&#125;&#125;&lt;/div&gt; el ： 选中元素，只有被选中的dom元素才能使用vue的语法* data：{} 存放vue实例对象的属性，双花括号中的属性会先到这里寻找对应的属性进行调用* v-bind属性绑定：可以用于响应式地更新 HTML 特性 123&lt;div id=\"app\"&gt;&#123;&#123;info&#125;&#125; &lt;a v-bind:href=\"url\"&gt;跳转到vue&lt;/a&gt;&lt;/div&gt; 在data中我们传入url这个属性 1234data:&#123; info:\"Vue\", url:\"https://cn.vuejs.org/v2/guide/\", &#125;, v-bind的缩写 ： 1&lt;a :href=\"url\"&gt;跳转到vue&lt;/a&gt; v-on事件绑定1&lt;button v-on:click = \"changeName\"&gt;点击&lt;/button&gt; 监听 DOM 事件 ，这里点击事件的函数名为 changeName ，将这个函数写入methods中。 methods：{} 存放vue实例对象的事件函数 1234567891011121314151617181920&lt;div id=\"app\"&gt;&#123;&#123;info&#125;&#125; &lt;a :href=\"url\"&gt;跳转到vue&lt;/a&gt; &lt;button v-on:click = \"changeName\"&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; info:\"Vue\", url:\"https://cn.vuejs.org/v2/guide/\", &#125;, methods:&#123; changeName()&#123; //this指vue实例对象，data中的属性直接用this进行调用 this.info += '!'; &#125; &#125; &#125;)&lt;/script&gt; 同样，v-on也可以进行缩写 1&lt;button :click = \"changeName\"&gt;点击&lt;/button&gt; v-html 指令双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令 12&lt;p v-html = \"tag\"&gt;&lt;/p&gt;&lt;p&gt;&#123;&#123;tag&#125;&#125;&lt;/p&gt; v-text指令1&lt;div v-text = \"text\"&gt;&lt;/div&gt; 123456data:&#123; info:\"Vue\", url:\"https://cn.vuejs.org/v2/guide/\", tag: \"&lt;span&gt;我是一个span标签&lt;/span&gt;\", text: \" &lt;div&gt;我是一个div标签&lt;/div&gt;\"&#125;, 二、计算属性和监听器模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。 当我想要拼接name，looks，和age时，使用模板表达式很麻烦。直接写入describe属性中有显得代码亢余 12345678910111213141516&lt;div id=\"app\"&gt;&#123;&#123;name&#125;&#125; &#123;&#123;looks&#125;&#125; &#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; name: 'ldw', looks: 'beautiful', describe: 'ldw beautiful 21', age: 21 &#125;, methods:&#123; &#125; &#125;) &lt;/script&gt; 那么使用 methods ，用函数来达到我们的目的如何呢？ 123456789101112131415161718&lt;div id=\"app\"&gt;&#123;&#123; describe() &#125;&#125;&lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; name: 'ldw', looks: 'beautiful', //describe: 'ldw beautiful', age: 21 &#125;, methods: &#123; describe()&#123; console.log(\"--------methods--------\"); return this.name + \" \" +this.looks; &#125; &#125;, &#125;) 函数返回了 name和looks这两个属性，并且渲染到页面 如此相比直接用模板语法来拼接确实简洁很多。 这里需要知道： 在控制台上修改了这两个属性的其中一个之后，函数会被再执行一次，也就是会再打印一次conslo语句。 简而言之就是，当视图重新渲染了就会再执行一次该函数 当我修改age属性呢？age属性并没有在describe函数中被调用。 上述结果看：我们修改属性影响视图渲染的同时，会涉及到重新加载无关的函数的问题，如此对性能十分不友好。 使用computed：{} 计算属性123456computed:&#123; describe() &#123; console.log(\"--------computed--------\"); return this.name + \" \" + this.looks; &#125; &#125;, 除了函数式写法外，还可以用对象的写法,有get和set方法 1234567891011121314describe:&#123; get()&#123; return this.name + \" \" + this.looks; &#125;, set(value)&#123; const arr = value.split(\" \"); this.name = arr[0]; this.looks = arr[1]; if(this.name === \"ldt\")&#123; this.age = 20; &#125; //console.log(value); &#125; &#125; 控制台输入： vm.describe = &quot;ldt&quot; 三、绑定class和style12345678910111213&lt;style&gt; p &#123; width: 100px; line-height: 100px; text-align: center; color: #fff; background: aquamarine; &#125; p.active &#123; background: slateblue; &#125;&lt;/style&gt; 12345678910111213&lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; activeBool:true, &#125;, methods:&#123; changeColor()&#123; this.activeBool = !this.activeBool; &#125; &#125; &#125;)&lt;/script&gt; class绑定对象写法：我们可以传给 v-bind:class 一个对象，以动态地切换 class： 123&lt;div id=\"app\"&gt; &lt;p v-bind:class = '&#123;active:activeBool&#125;' @click = 'changeColor'&gt;LDW&lt;/p&gt; &lt;!--可简写--&gt;&lt;/div&gt; v-bind:class = ‘{active:activeBool}’ active -&gt; 需要绑定的class名，activeBool -&gt; 布尔值，决定绑定成功与否，true/false -&gt; 成功/失败 数组写法：我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： 1&lt;p :class=\"[active]\" @click=\"changeColor\"&gt;LDW&lt;/p&gt; 通过点击事件触发changeColor函数，修改绑定的class名为active或者是空，达到修改样式的效果 1234changeColor()&#123; // this.activeBool = !this.activeBool; return this.active = this.active === 'active' ? '' : 'active' &#125; style绑定对象写法：看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;h1 :style=\"&#123;color:'#eee'&#125;\"&gt;hello Vue&lt;/h1&gt; 数组写法 可以将多个样式对象应用到同一个元素上 1&lt;p :class=\"[active]\" @click=\"changeColor\" :style=\"[styleObj,colorStyleObj]\"&gt;LDW&lt;/p&gt; 在data中写入 styleObj 和 colorStyleObj 12345678910data:&#123; active:'', styleObj:&#123; width:'200px', lineHeight:'200px' &#125;, colorStyleObj:&#123; background:'#ddd' &#125; &#125;, 四、条件渲染代码样式部分 12345678910111213&lt;style&gt; p &#123; width: 100px; line-height: 100px; text-align: center; color: #fff; background: aquamarine; &#125; p.active &#123; background: slateblue; &#125;&lt;/style&gt; V-show控制元素的display，带有v-show的元素始终会被渲染并保留在dom之中。 1234&lt;div id=\"app\"&gt; &lt;button @click=\"showOrHide\"&gt; show/hide &lt;/button&gt; &lt;p v-show = \"show\"&gt;ldw&lt;/p&gt;&lt;/div&gt; 12345678910111213&lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; show:true //控制show的布尔值达到display显示和隐藏的效果 &#125;, methods:&#123; showOrHide()&#123; this.show = !this.show; //更改布尔值 &#125; &#125; &#125;) &lt;/script&gt; v-if / v-else / v-if-else12&lt;p v-if = 'show'&gt;ldw&lt;/p&gt; &lt;span v-else&gt;盒子已经隐藏了&lt;/span&gt; 这里如果v-if和v-else一起使用的话中间不能插入其他html结构 可以看出，v-if是动态的控制dom元素的添加和删除 v-if 和 v-show 的异同点二者区别 (1)手段： ​ v-if是动态的向DOM树内添加或者删除DOM元素； ​ v-show是通过设置DOM元素的display样式属性控制显隐； (2)编译过程： ​ v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； ​ v-show只是简单的基于css切换； (3)编译条件： ​ v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译 ​ v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； (4)性能消耗： ​ v-if有更高的切换消耗； ​ v-show有更高的初始渲染消耗； (5)使用场景： ​ v-if适合运营条件不大可能改变； ​ v-show适合频繁切换。 五、列表渲染v-for 指令我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。 样式部分： 1234567891011121314151617181920*&#123; margin: 0; padding: 0; list-style: none; &#125; ul&#123; margin: 100px; &#125; li&#123; line-height: 30px; &#125; p&#123; display: inline-block; &#125; span&#123; padding: 2px; color: red; border: 1px solid red; font-size: 12px; &#125; html结构： 123456789&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in newList\" :key = \"item.id\"&gt; &lt;!-- 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 --&gt; &lt;p&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;span v-if=\"item.new\"&gt;新&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; JS部分，我们在data中添加一个newList数组，数组中存放不同对象 1234567891011121314151617181920212223242526272829303132newList:[ &#123; title: \"张柏芝第三胎生父\", new:true, id:0 &#125;, &#123; title: \"被约谈艺人名单\", new:true, id:1 &#125;, &#123; title: \"陈羽凡吸毒\", new:true, id:2 &#125;, &#123; title: \"李连杰首晒与女儿合照\", new:false, id:3 &#125;, &#123; title: \"黄智贤节目抨击台独\", new:true, id:4 &#125;, &#123; title: \"安徽一校长呼吁抵制洋节\", new:false, id:5 &#125; ] 效果： 数组更新检测注意事项 ：由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当我们在控制台动态的去修改数组的时候，视图并不会因此改变，所以VUE提供了一套数组变异的方法来检测数组变动并触发视图的更新。 数组变异的方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() 往数组最后面添加一个元素，成功返回当前数组的长度 pop() 删除数组的最后一个元素，成功返回删除元素的值 shift() 删除数组的第一个元素，成功返回删除元素的值 unshift() 往数组最前面添加一个元素，成功返回当前数组的长度 splice() 有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选）， 第三个是删除 后想要在原位置替换的值（可选） sort() 使数组按照字符编码默认从小到大排序,成功返回排序后的数组 reverse() 将数组倒序，成功返回倒序后的数组 通过push（）方法成功添加了一条信息并且视图进行渲染。 set（） 和 $set（） 方法为了解决vue不能检测变动的数组 ，除了使用变异方法之外，vue还提供了set方法 1Vue.set ( vm.items, indexOfItem, newValue ) 1vm.$set(vm.items, indexOfItem, newValue) 用v-for进行对对象的迭代123&lt;ul&gt; &lt;li v-for='value in useObj'&gt;&#123;&#123; value &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 12345data:&#123; useObj:&#123; name: 'LDW', age: 21 &#125;, 也可以提供第二个的参数为键名： 123&lt;ul&gt; &lt;li v-for='(value,Key) in useObj'&gt;&#123;&#123; value &#125;&#125; &#123;&#123;Key&#125;&#125;&lt;/li&gt;&lt;/ul&gt; name是Key值，‘LDW’是value值 第三个参数为索引： 123&lt;ul&gt; &lt;li v-for=&apos;(value,Key，index) in useObj&apos;&gt;&#123;&#123; value &#125;&#125; &#123;&#123;Key&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 同样用Vue.set方法 六、事件处理 &amp; 表单输入绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;style&gt; *&#123; list-style: lower-alpha; &#125; span&#123; color: red; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &lt;!-- 这里如果用change事件来监听的话，当我们button的点击触发addTask，代码运行到 this.inputVal = ''; 的时候，会被change监听到input中发生了输入空白字符串， 从而再触发了一次addTask函数，故用Keyup事件 --&gt; &lt;!-- v-model : 在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。负责监听用户的输入事件以更新数据. 监听到输入的数据会传递给inputVal。 trim：动过滤用户输入的首尾空白字符 --&gt; &lt;input type=\"text\" v-model.trim= \"inputVal\" @Keyup.enter = \"addTask\"&gt; &lt;button @click = 'addTask'&gt;提交&lt;/button&gt; &lt;span&gt;&#123;&#123;propmt&#125;&#125;&lt;/span&gt; &lt;ul&gt; &lt;li v-for='(item,index) in todoList' :Key = 'item'&gt; &#123;&#123; item &#125;&#125; &lt;button @click = 'completeTask(index)'&gt;X&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;h4&gt;已完成任务&lt;/h4&gt; &lt;ul&gt; &lt;li v-for='item in completeList'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; propmt:'', todoList:[], completeList:[], inputVal:'', //存放input输入 &#125;, methods:&#123; addTask()&#123; //判断是否重复（判断todoList数组中是否存在这个value值） if(this.todoList.includes(this.inputVal))&#123; this.propmt = \"不能重复输入\"; &#125; else if(this.inputVal === '')&#123; //判断是否为空字符串 this.propmt = '输入不可为空'; return; &#125;else&#123; this.todoList.push(this.inputVal); //将input输入的东西存入数组 this.inputVal = ''; //再清空input框 &#125; &#125;, completeTask(index)&#123; const task = this.todoList.splice(index,1); //删除 // console.log(...task); this.completeList.push(...task); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、组件全局组件1234567891011121314151617&lt;body&gt; &lt;div id=\"app\"&gt; &lt;course-list&gt;&lt;/course-list&gt; &lt;/div&gt; &lt;script&gt; Vue.component('course-list',&#123; template:`&lt;div&gt; I am a cmp &lt;/div&gt;` &#125;); const vm = new Vue(&#123; el:'#app', data:&#123; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 局部组件1234567891011121314151617181920212223&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- &lt;course-list&gt;&lt;/course-list&gt; --&gt; &lt;course&gt;&lt;/course&gt; &lt;/div&gt; &lt;script&gt; // Vue.component('course-list',&#123; // template:`&lt;div&gt; I am a cmp &lt;/div&gt;` // &#125;); const vm = new Vue(&#123; el:'#app', components:&#123; course:&#123; template:`&lt;div&gt; I am a cmp &lt;/div&gt;` &#125; &#125;, data:&#123; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 运用vue组件制作一个商品列表样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;style&gt; * &#123; padding: 0; margin: 0; list-style: none; &#125; #app &#123; display: inline-block; margin: 20px; border: 1px solid #000; padding: 20px; padding-bottom: 0; font-size: 14px; cursor: pointer; &#125; .course &#123; display: flex; margin-bottom: 15px; &#125; .img-box &#123; position: relative; margin-right: 20px; &#125; .course-img &#123; width: 140px; height: 80px; vertical-align: bottom; &#125; .course span &#123; box-sizing: border-box; position: absolute; bottom: 0; display: block; width: 100%; line-height: 20px; padding-left: 10px; color: #fff; font-size: 10px; background-color: #000; opacity: 0.6; &#125; .title &#123; width: 250px; box-sizing: border-box; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; &#125; .free &#123; color: #5fb41b; &#125; .play-back &#123; display: inline-block; padding: 0 3px; font-size: 12px; border: 1px solid #73b3e7; color: #73b3e7; &#125; .price &#123; color: #e85308; &#125; .choose &#123; opacity: .3; &#125; &lt;/style&gt; 我们需要一个存放数据的列表：$$courseList:[ { name: ‘Web前端开发之JavaScript(Js)精英课堂【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 4942, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBsSud06XlZnJACsTWd7OSA5phIFPRTNibFBeuT8jRjy00Jb5ticSEKYUnpUYdBCicH2U/356&#39; }, { name: ‘Web前端开发之HTML+CSS精英课堂【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 2982, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBDFLdArBwf70PjMrL6bq0OI9LesEsskk1iamJKibriaic0QkBZhINoDuN0DicaojkqyQjk/356&#39; }, { name: ‘淘宝商城项目实战开发【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1742, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDBpXKL1sgAOKcbSz0Od2abiaqdJibiaDDQWfmrVNBCFrIpbTQKlNyWbPg5Uo1dnT7Znk/356&#39; }, { name: ‘零基础WEB前端入门’, free: false, playback: true, price: 9.9, buyNumber: 2514, enrollment: 0, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCRlDgtxVbmyclxP9fDUYmnuqAFbN5mYsncrPrVyQbtA3fNfuZ3qicSe1r7Ppt7tICs/356&#39; }, { name: ‘React顶级企业实战，全流程制作淘票票WebApp【渡一教育】’, free: false, playback: true, price: 399, buyNumber: 670, enrollment: 0, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLB2CyXIxsb8iaAUibBB9mzlkSgKNU7GiciaYxG1SicoLjkiahZ3ia54eZWbtCGDkFyvMo0uKk/356&#39; }, { name: ‘原生JS贪吃蛇游戏实战开发【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1123, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCfsOGnxjhUXFA6SHMOu0fMUicuucRlIVNo9zBnnLiacovMnePD6586QlRj2qvwudbn8/356&#39; }, { name: ‘原生JS扫雷游戏实战开发【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 631, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDaTljUSVGk2eqS1MCT3DwDqxgs7KhfMf3411SXQkRvmiaicIuz47ydO27zGPWK97wicw/356&#39; }, { name: ‘你不知道的Javascript【渡一教育】’, free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1696, poster: ‘https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCelo2lyibtrxDia7aq7tC0LE1Lcz2LVoDqhQy5tnOHicTzWhLuvPekL35rEmwTdgNuwI/356&#39; } ]$$html结构 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li class=\"course\"&gt; &lt;div class=\"img-box\"&gt; &lt;img src=\"https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBsSud06XlZnJACsTWd7OSA5phIFPRTNibFBeuT8jRjy00Jb5ticSEKYUnpUYdBCicH2U/356\" alt=\"\" class=\"course-img\"&gt; &lt;span&gt;人报名&lt;/span&gt; &lt;span&gt;购买&lt;/span&gt; &lt;/div&gt; &lt;div class=\"course-box\"&gt; &lt;div class=\"title\"&gt;标题标题标题标题标题&lt;/div&gt; &lt;div class=\"free\"&gt;免费&lt;/div&gt; &lt;div class=\"play-back\"&gt;回放&lt;/div&gt; &lt;div class=\"price\"&gt;￥99&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 将#app挂载到 vue，同时我们定义一个名为‘ List ’ 的局部组件 1234567891011121314151617&lt;script&gt; const List = &#123; template:``, data()&#123; &#125; &#125;, const vm = new Vue(&#123; el:'#app', data:&#123; &#125;, components:&#123; List &#125; &#125;)&lt;/script&gt; 渲染到页面的基础效果 基础效果没问题了，我们直接将这段html结构作为一个模板，放入我们定义好的List组件中的 template 中，同时在#app中使用我们的组件 123&lt;div id=\"app\"&gt; &lt;List&gt;&lt;/List&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627const List = &#123; template:`&lt;ul&gt; &lt;li class=\"course\"&gt; &lt;div class=\"img-box\"&gt; &lt;img src=\"https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBsSud06XlZnJACsTWd7OSA5phIFPRTNibFBeuT8jRjy00Jb5ticSEKYUnpUYdBCicH2U/356\" alt=\"\" class=\"course-img\"&gt; &lt;span&gt;人报名&lt;/span&gt; &lt;span&gt;购买&lt;/span&gt; &lt;/div&gt; &lt;div class=\"course-box\"&gt; &lt;div class=\"title\"&gt;标题标题标题标题标题&lt;/div&gt; &lt;div class=\"free\"&gt;免费&lt;/div&gt; &lt;div class=\"play-back\"&gt;回放&lt;/div&gt; &lt;div class=\"price\"&gt;￥99&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;` &#125;const vm = new Vue(&#123; el:'#app', components:&#123; List &#125;, data:&#123; &#125;&#125;); 八、父子组件通信继续完成列表渲染 这里我们要用到courseList数组中的数据，将它写入vm实例的data{}中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const vm = new Vue(&#123; el: '#app', components: &#123; List &#125;, data: &#123; courseList: [ &#123; name: 'Web前端开发之JavaScript(Js)精英课堂【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 4942, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBsSud06XlZnJACsTWd7OSA5phIFPRTNibFBeuT8jRjy00Jb5ticSEKYUnpUYdBCicH2U/356' &#125;, &#123; name: 'Web前端开发之HTML+CSS精英课堂【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 2982, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBDFLdArBwf70PjMrL6bq0OI9LesEsskk1iamJKibriaic0QkBZhINoDuN0DicaojkqyQjk/356' &#125;, &#123; name: '淘宝商城项目实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1742, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDBpXKL1sgAOKcbSz0Od2abiaqdJibiaDDQWfmrVNBCFrIpbTQKlNyWbPg5Uo1dnT7Znk/356' &#125;, &#123; name: '零基础WEB前端入门', free: false, playback: true, price: 9.9, buyNumber: 2514, enrollment: 0, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCRlDgtxVbmyclxP9fDUYmnuqAFbN5mYsncrPrVyQbtA3fNfuZ3qicSe1r7Ppt7tICs/356' &#125;, &#123; name: 'React顶级企业实战，全流程制作淘票票WebApp【渡一教育】', free: false, playback: true, price: 399, buyNumber: 670, enrollment: 0, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLB2CyXIxsb8iaAUibBB9mzlkSgKNU7GiciaYxG1SicoLjkiahZ3ia54eZWbtCGDkFyvMo0uKk/356' &#125;, &#123; name: '原生JS贪吃蛇游戏实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1123, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCfsOGnxjhUXFA6SHMOu0fMUicuucRlIVNo9zBnnLiacovMnePD6586QlRj2qvwudbn8/356' &#125;, &#123; name: '原生JS扫雷游戏实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 631, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDaTljUSVGk2eqS1MCT3DwDqxgs7KhfMf3411SXQkRvmiaicIuz47ydO27zGPWK97wicw/356' &#125;, &#123; name: '你不知道的Javascript【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1696, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCelo2lyibtrxDia7aq7tC0LE1Lcz2LVoDqhQy5tnOHicTzWhLuvPekL35rEmwTdgNuwI/356' &#125; ] &#125; &#125;); 接下就可以用绑定数据的方式向子组件传入数据 123&lt;div id=\"app\"&gt; &lt;List :list = \"courseList\"&gt;&lt;/List&gt;&lt;/div&gt; 冒号，v-on的缩写形式 props我们定义的vue实例其实就是一个组件，而List组件可以视作是子组件，父组件向子组件传的数据，都要通过子组件的props选项。 注意： 组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，需要通过子组件的 props 选项 子组件要显式地用 props 选项声明它期待获得的数据 ，并且需要定义属性类型。default为默认值，当父组件没传值时，走默认值。required为true规定父组件必须传值，否则报错。 123456789const List = &#123; props:&#123; list:&#123; type: Array, default:[], required: true &#125;, &#125;, ··········· 父组件传值成功后，我们html结构中使用这个list数据 123456789101112131415161718template: ` &lt;ul&gt; &lt;li v-for = \"(item,index) in list\" :key = 'item.name' class=\"course\"&gt; &lt;div class=\"img-box\"&gt; &lt;img :src=\"item.poster\" alt=\"\" class=\"course-img\"&gt; &lt;span&gt;&#123;&#123;item.enrollment&#125;&#125;人报名&lt;/span&gt; &lt;span&gt;&#123;&#123;item.buyNumber&#125;&#125;购买&lt;/span&gt; &lt;/div&gt; &lt;div class=\"course-box\"&gt; &lt;div class=\"title\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;div class=\"free\" v-if = \"item.free\"&gt;免费&lt;/div&gt; &lt;div class=\"play-back\" v-if = \"item.playback\"&gt;回放&lt;/div&gt; &lt;div class=\"price\"&gt;￥&#123;&#123;item.enrollment&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;` 效果： 在子组件中添加事件，添加/删除购物车，计算总价接着给li标签（每一个商品选项）添加一个点击事件，来写一个添加/删除购物车，计算总价的效果。 li标签绑定 ‘ addToBuy ’ 事件，并在子组件的methods中定义 同时我们需要用到一个属性，使用一个数组 （totalPriceArr:[]）来存放每次添加后的 ‘ price ’ ，与父组件属性写在data：{} 对象中不同，子组件有组件的data函数，用来存放自己的属性。 1@click = 'addToBuy(index,item.price)' 子组件的data函数需要返回一个对象，而我们需要用到的属性就是存放在这个对象中，写法如下： 12345data()&#123; return &#123; totalPriceArr:[], &#125; &#125; 我们将点击的哪一项的 price 的值添加到 totalPriceArr:[] 数组中去。 123addToBuy(index,price)&#123; this.totalPriceArr.push(price); &#125; 但是这样存在一个问题：每次重复点击同一项时会重复触发添加效果 解决重复添加 price 的办法我们还需要一个数组，通过每一个商品项的索引值index，以判断数组 Array[ index ] 布尔值的方式，来决定是否触发 添加事件（ this.totalPriceArr.push(price); ）。写法如下： 定义一个数组： 123456data()&#123; return &#123; totalPriceArr:[], alreadyHasArr:[], &#125; &#125; addToBuy（） ： 123456addToBuy(index,price)&#123; if(alreadyHasArr[index])&#123; return ; //如果存在 alreadyHasArr[index] ，就用return的方法阻止后面代码的运行 &#125; this.totalPriceArr.push(price); &#125; 点击添加商品后背景变灰效果我们在模板中的li标签里，用绑定的方式添加class名 1:class=\"&#123;course:true , choose:alreadyHasArr[index]&#125;\"&gt; alreadyHasArr[index] 的布尔值取决于我们是否点击添加了商品项，如果点击，添加了，alreadyHasArr[index] 的值就为true，同时choose样式就成功绑定了li标签。 虽然我们使用改变数组的布尔值来决定类名的绑定，但是不要忘记： 由于javascript的限制，Vue无法检查得到数组的变动。所以，我们还需要用Vue提供的数组变异的方法来让它检测得到数组的变动，从而达到我们改变视图的效果 1this.$set(this.alreadyHasArr,index,true); 计算添加的商品总价格定义一个属性用来存放总价格 ——- totalPrice ，默认值为0 定义一个回调函数用来计算商品总价，这里需要使用数组的reduce 方法来进行每项商品价格的加法运算 12345678910Price()&#123; if(this.totalPriceArr.length === 0)&#123; this.totalPrice = 0; &#125;else&#123; this.totalPrice = this.totalPriceArr.reduce((pre,cur) =&gt; &#123; return pre + cur; &#125;); &#125; console.log(this.totalPrice); &#125; 再在addToBuy函数中进行调用。 （ 不要忘记用this进行调用 ） 添加点击鼠标右键商品移除购物车事件1@contextmenu.prevent = &apos;removeFromBuy(index,item.price)&apos; .prevent : 取消鼠标右键的默认事件（弹出菜单） 传入索引和价格，用来取消choose的绑定和总价的计算 1234567891011121314removeFromBuy(index,price)&#123; if(!this.alreadyHasArr[index])&#123; return &#125; //修改点击项的布尔值取消choose样式的绑定 this.$set(this.alreadyHasArr,index,false); //找出值等于price的数在totalPriceArr数组中是第几项 const totalPriceIndex = this.totalPriceArr.findIndex(index =&gt; &#123; return index == price; &#125;); //知道该移除的数是第几项之后使用splice从数组中移除 this.totalPriceArr.splice(totalPriceIndex,1); this.Price(); &#125; 思路： 将商品移除，我们添加商品时商品价格存放入totalPriceArr数组之中，移除时我们需要知道点击移除的是哪一项，具体在totalPriceArr数组中的第几位，需要用到数组的findIndex方法。 而findIndex中的这个值，使用匿名函数返回出一个index值，让它等于我们点击移除的商品的价格，赋值给我们定义的常量totalPriceIndex。然后就能使用数组的splice方法，将totalPriceArr数组中的值等于totalPriceIndex进行移除。 子组件向父组件传值 （ $emit函数 ）我们需要将子组件中的 totalPrice 传给父组件，再由父组件渲染到视图上 1234&lt;div id=\"app\"&gt; &lt;List :list = \"courseList\"&gt;&lt;/List&gt; 合计：&#123;&#123; totalPrice &#125;&#125;&lt;/div&gt; 双花括号的属性在父组件的data：{}中定义，初始值为0 那么子组件需要通过$emit函数向父组件传值，emit函数第一个参数为一个自定义事件，第二个参数是需要传的值 我们需要传totalPrice的值到父组件，在Price函数中使用$emit函数。之后在子组件中用v-on指令监听自定义事件 1this.$emit(&apos;price&apos;,this.totalPrice); 1234&lt;div id=\"app\"&gt; &lt;List :list = \"courseList\" @price = 'getPrice'&gt;&lt;/List&gt; 合计：&#123;&#123; totalPrice &#125;&#125;&lt;/div&gt; 让这个自定义事件等于一个getPirce函数，如此子组件传递给父组件的值我们就可以在这个函数中使用了 12345678910const vm = new Vue(&#123; el: '#app', components: &#123; List &#125;, methods:&#123; getPrice(price)&#123; //参数price就是从子组件传出来的值 this.totalPrice = price; &#125; &#125;, 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;body&gt; &lt;div id=\"app\"&gt; &lt;List :list=\"courseList\" @price='getPrice'&gt;&lt;/List&gt; 合计：&#123;&#123; totalPrice &#125;&#125; &lt;/div&gt; &lt;script&gt; const List = &#123; props: &#123; list: &#123; type: Array, default: [], required: true &#125;, &#125;, template: ` &lt;ul&gt; &lt;li v-for = \"(item,index) in list\" :key = 'item.name' @click = 'addToBuy(index,item.price)' @contextmenu.prevent = 'removeFromBuy(index,item.price)' :class=\"&#123;course:true , choose:alreadyHasArr[index]&#125;\"&gt; &lt;div class=\"img-box\"&gt; &lt;img :src=\"item.poster\" alt=\"\" class=\"course-img\"&gt; &lt;span&gt;&#123;&#123;item.enrollment&#125;&#125;人报名&lt;/span&gt; &lt;span&gt;&#123;&#123;item.buyNumber&#125;&#125;购买&lt;/span&gt; &lt;/div&gt; &lt;div class=\"course-box\"&gt; &lt;div class=\"title\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;div class=\"free\" v-if = \"item.free\"&gt;免费&lt;/div&gt; &lt;div class=\"play-back\" v-if = \"item.playback\"&gt;回放&lt;/div&gt; &lt;div class=\"price\" v-if = 'item.price'&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;`, methods: &#123; addToBuy(index, price) &#123; if (this.alreadyHasArr[index]) &#123; return; //如果存在 alreadyHasArr[index] ，就用return的方法阻止后面代码的运行 &#125; this.totalPriceArr.push(price); this.$set(this.alreadyHasArr, index, true); this.Price(); &#125;, Price() &#123; if (this.totalPriceArr.length === 0) &#123; this.totalPrice = 0; &#125; else &#123; this.totalPrice = this.totalPriceArr.reduce((pre, cur) =&gt; &#123; return pre + cur; &#125;); &#125; console.log(this.totalPrice); this.$emit('price', this.totalPrice); &#125;, removeFromBuy(index, price) &#123; if (!this.alreadyHasArr[index]) &#123; return &#125; this.$set(this.alreadyHasArr, index, false); const totalPriceIndex = this.totalPriceArr.findIndex(index =&gt; &#123; return index == price; &#125;); this.totalPriceArr.splice(totalPriceIndex, 1); this.Price(); &#125; &#125;, data() &#123; return &#123; totalPriceArr: [], alreadyHasArr: [], totalPrice: 0 &#125; &#125; &#125; const vm = new Vue(&#123; el: '#app', components: &#123; List &#125;, methods: &#123; getPrice(price) &#123; //参数price就是从子组件传出来的值 this.totalPrice = price; &#125; &#125;, data: &#123; totalPrice: 0, courseList: [&#123; name: 'Web前端开发之JavaScript(Js)精英课堂【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 4942, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBsSud06XlZnJACsTWd7OSA5phIFPRTNibFBeuT8jRjy00Jb5ticSEKYUnpUYdBCicH2U/356' &#125;, &#123; name: 'Web前端开发之HTML+CSS精英课堂【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 2982, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLBDFLdArBwf70PjMrL6bq0OI9LesEsskk1iamJKibriaic0QkBZhINoDuN0DicaojkqyQjk/356' &#125;, &#123; name: '淘宝商城项目实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1742, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDBpXKL1sgAOKcbSz0Od2abiaqdJibiaDDQWfmrVNBCFrIpbTQKlNyWbPg5Uo1dnT7Znk/356' &#125;, &#123; name: '零基础WEB前端入门', free: false, playback: true, price: 9.9, buyNumber: 2514, enrollment: 0, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCRlDgtxVbmyclxP9fDUYmnuqAFbN5mYsncrPrVyQbtA3fNfuZ3qicSe1r7Ppt7tICs/356' &#125;, &#123; name: 'React顶级企业实战，全流程制作淘票票WebApp【渡一教育】', free: false, playback: true, price: 399, buyNumber: 670, enrollment: 0, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLB2CyXIxsb8iaAUibBB9mzlkSgKNU7GiciaYxG1SicoLjkiahZ3ia54eZWbtCGDkFyvMo0uKk/356' &#125;, &#123; name: '原生JS贪吃蛇游戏实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1123, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCfsOGnxjhUXFA6SHMOu0fMUicuucRlIVNo9zBnnLiacovMnePD6586QlRj2qvwudbn8/356' &#125;, &#123; name: '原生JS扫雷游戏实战开发【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 631, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLDaTljUSVGk2eqS1MCT3DwDqxgs7KhfMf3411SXQkRvmiaicIuz47ydO27zGPWK97wicw/356' &#125;, &#123; name: '你不知道的Javascript【渡一教育】', free: true, playback: false, price: 0, buyNumber: 0, enrollment: 1696, poster: 'https://10.url.cn/qqcourse_logo_ng/ajNVdqHZLLCelo2lyibtrxDia7aq7tC0LE1Lcz2LVoDqhQy5tnOHicTzWhLuvPekL35rEmwTdgNuwI/356' &#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 玩转 vue 全家桶 二九、动态组件、插槽 注册两个组件cmp-one和cmp-two，通过 Vue 的 component 标签加一个特殊的 is 特性来实现： 123456const cmpOne = &#123; template:` &lt;div&gt;组件1：&lt;input type=\"value\"&gt;&lt;/div&gt; `&#125;const cmpTwo = &#123; template:` &lt;div&gt;组件2：&lt;input type=\"value\"&gt;&lt;/div&gt; `&#125; 1234&lt;div id=\"app\"&gt; &lt;button @click = 'changeCmp'&gt;切换&lt;/button&gt; &lt;component :is = 'type'&gt;&lt;/component&gt;&lt;/div&gt; 123456789101112131415const vm = new Vue(&#123; el:'#app', data:&#123; type: 'cmp-one' &#125;, components:&#123; cmpOne, cmpTwo &#125;, methods:&#123; changeCmp()&#123; this.type = this.type == 'cmp-one'? 'cmp-two' : 'cmp-one' &#125; &#125; &#125;); 在动态组件上使用keep-alive当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。 上面代码中，我们在组件1的input框输入的东西，切换到组件2，再切换回来的时候是不会展示之前输入的数据的，为了解决这个问题，我们可以用一个 &lt;keep-alive&gt; 元素将其动态组件包裹起来 。 123&lt;keep-alive&gt; &lt;component :is = 'type'&gt;&lt;/component&gt;&lt;/keep-alive&gt; 插槽插槽就是Vue实现的一套内容分发的API，将 元素作为承载分发内容的出口。 这句话的意思就是，没有插槽的情况下在组件标签内些一些内容是不起任何作用的 12345&lt;div id=\"app\"&gt; &lt;cmp&gt; hello &lt;/cmp&gt;&lt;/div&gt; 定义一个cmp的子组件，模板为： 12345cmp:&#123; template:`&lt;h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt;` &#125; 这里 h1 标签中的 slot 元素就作为了承载分发内容的出口， 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为我们写在cmp组件里的 “hello”。 插槽内可以包含任何模板代码，包括 HTML： 12345&lt;div id=\"app\"&gt; &lt;cmp&gt; &lt;span&gt; hello &lt;/span&gt; &lt;/cmp&gt;&lt;/div&gt; 如此 slot 元素就会被 “ hello ” 这块html结构替换掉。 如果 组件cmp 没有包含一个 &lt;slot&gt; 元素，则任何传入它的内容都会被抛弃。 具名插槽当我们需要多个插槽的时候，&lt;slot&gt; 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽： 12345678910111213const baseLayout = &#123; template: `&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;`&#125; 往具名插槽内放内容的时候，要在一个父组件的 &lt;template&gt; 元素上使用 slot 特性： 1234567891011121314&lt;div class=\"app\"&gt; &lt;base-layout&gt; &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template slot=\"footer\"&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt; &lt;/base-layout&gt;&lt;/div&gt; 另一种 slot 特性的用法是直接用在一个普通的元素上： 1&lt;h3 slot=\"center\"&gt;center text&lt;/h3&gt; 子组件template中的插槽： 1&lt;slot name=\"center\"&gt;&lt;/slot&gt; 作用域插槽子组件show-book接受从父组件传来的bookList数组，将这个数组在需要承载内容的slot元素中使用v-for循环，然后通过v-on:bookInfo = ‘item’ 的方式将数组的每一项‘ item ’绑定为一个对象bookInfo传递给父组件，父组件通过slot-scope = ‘ show ’ 的方式，接收bookInfo对象，之后就可以使用show.bookInfo.name的方式决定子组件中的数据如何渲染，渲染哪些。 12345&lt;show-book :book = \"bookList\"&gt; &lt;template slot-scope = \"show\"&gt; &lt;li&gt;&#123;&#123;show.bookInfo.name&#125;&#125;&lt;/li&gt; &lt;/template&gt;&lt;/show-book&gt; 1234567891011121314151617181920212223const showBook = &#123; props:['book'], template:` &lt;ul&gt; &lt;slot v-for = \"item in book\" :bookInfo = 'item'&gt;&lt;/slot&gt; &lt;/ul&gt; `&#125;const vue = new Vue(&#123; el: '.app', components: &#123; // baseLayout, showBook, &#125;, data:&#123; bookList:[ &#123;name:'《三国志》'&#125;, &#123;name:'《隋唐演义》'&#125;, &#123;name:'《聊斋》'&#125;, &#123;name:'《吕氏春秋》'&#125;, ] &#125;&#125;); 进一步理解作用域插槽： 这里子组件的数据是由父组件传递进去，子组件循环之后又通过作用域插槽返回给父组件再由父组件决定渲染方式，那么为什么不直接让数据就在父组件中进行渲染呢？ 看vue官方给出的原话：有的时候你希望提供的组件带有一个可从子组件获取数据的可复用的插槽。 我们使用组件就是为了可复用，但是我们渲染数据的方式又得是组件的调用者来决定的，所有我们需要一个带有数据的插槽，这就是作用域插槽的用武之地。 十、vue生命周期1.vue实例创建前 ————- beforeCreate 2.vue实例创建完毕 ——— created 3.查看是否存在 el 这个属性，如果有继续第4点，如果没有，则等待我们执行vm.$mount(el)函数 4.查看是否存在template属性，如果有，就将template编译后放入render函数里面，也就是将data对象中的数据和vue语法写的模板编译成html，否则，将外部HTML作为模板编译 5.挂载编译生成的html之前 —————–beforeMount 此时还没将编译出的html渲染到页面 6.挂载 ———————mounted 将编译出的html替换到el属性所指的dom对象或者替换对应的html标签里面的内容，渲染到页面。 7.更新前 ————— beforeUpdate mounted在整个vue生命周期中只执行一次，他会实时监控data的数据变化，随时更新dom， 8.更新 —————– updated 9.实例销毁前 ———— beforeDestroy 10.实例销毁，#app 挂载失效，生命周期结束 ———– destroyed 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div id=\"app\"&gt; &#123;&#123;msg&#125;&#125; &lt;button @click = 'change'&gt;点击更改msg&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125;, methods:&#123; test()&#123; console.log('hahahahahaha'); &#125;, change()&#123; this.msg = 'hi vue' &#125; &#125;, beforeCreate()&#123; console.log('-----------beforeCreate------------'); //创建vue实例之前，data，methods都还没有 console.log(this.msg); //undefined ，还没创建出来 console.log(this.test); //undefined ，还没创建出来 alert('beforeCreate'); &#125;, created()&#123; console.log('-----------Create------------'); //创建vue实例完毕 console.log(this.msg); //hello //console.log(this.test); this.test(); //hahahahaha alert('create'); &#125;, beforeMount()&#123; alert('beforeMount'); &#125;, mounted()&#123; alert('mounted'); &#125;, beforeUpdate()&#123; alert('beforeUpdate'); &#125;, updated()&#123; alert('updated'); &#125;, //控制台：vm.$destroy() beforeDestroy()&#123; alert('bd'); &#125;, destroyed()&#123; alert('des'); &#125; //生命周期结束 &#125;) &lt;/script&gt; 十一、vue-cli创建项目全局安装： 1npm install -g @vue/cli cd到想到插件vue项目的位置，创建vue项目 1vue create &apos;项目名&apos; 提供两种预设，第一种默认安装了babel（不陌生了，转为es5语法的），第二种是自定义预设。 选择第二种进入这个界面 这里我们暂时先用babel，其他的不选，空格为取消选中 这里问是否将各种配置放置在单独的文件里？ 那我们把这些配置放置在同一个文件里可以方便我们查看，选中 in package.json 这选项。回车 Save this as a preset for future projects? 将此保存为未来项目的预置? 我们下次使用vue-cli搭建项目时就可以使用上一次使用的预设配置了。需要的话y，反之n 接下来填写我们创建的vue项目的项目名，回车等待安装各种插件和项目创建 项目名是vue-app 创建成功，cd到项目，code . 打开编辑器，再npm run serve 运行起这个vue项目 十二、路由安装路由1vue add router 为这个路由使用模式？ 先no着 安装之后看看砸门的编辑器里多了一个几个文件 多了views文件夹和router.js main.js中导入了vue-router ： 1import router from './router' 我们来自己配置一次路由，先取消main文件中路由的导入，","categories":[],"tags":[]}]}